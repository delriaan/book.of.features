if (is.null(names(bvec))){ names(bvec) <- bvec }
if (chatty){ print(list(fvec = c(fvec), avec = c(avec), bvec = bvec, out.names = out.names)) }
action <- { rlang::exprs(
# logical.out = TRUE; `==` ~ <default>
`100` = outer(fvec, bvec, `==`)
, # avec ~ logical.out = FALSE; `==` ~ <default>
`000` = outer(fvec, bvec, `==`) * avec
, # logical.out = TRUE, {purrr::map; `%in% } ~ fvec[]
`101` = purrr::map(fvec, ~rlang::set_names(bvec %in% .x, bvec)) |> purrr::reduce(rbind)
, # avec ~ logical.out = FALSE; {purrr::map; `%in% } ~ fvec[]
`001` = purrr::map(fvec, ~rlang::set_names(bvec %in% .x, bvec)) |> purrr::reduce(rbind) * avec
, # logical.out = TRUE; stringi::stri_detect_regex ~ regex
`110` = outer(fvec, bvec, stringi::stri_detect_regex)
, # avec ~ logical.out = FALSE; `stringi::stri_detect_regex ~ regex
`010` = outer(fvec, bvec, stringi::stri_detect_regex) * avec
, # logical.out = TRUE, stringi::stri_detect_regex ~ regex, {purrr::map; `%in% } ~ fvec[]
`111` = purrr::map(fvec, ~rlang::set_names(stringi::stri_detect_regex(.x, bvec), bvec)) |>
purrr::reduce(rbind)
, # avec ~ logical.out = FALSE, stringi::stri_detect_regex ~ regex, {purrr::map; `%in% } ~ fvec[]
`011` = purrr::map(fvec, ~{ fv = .x; purrr::map_lgl(bvec, ~stringi::stri_detect_regex(fv, .x) |> any()) }) |>
purrr::reduce(rbind)* avec
)[paste(as.numeric(logical.out), as.numeric(regex), as.numeric(is.list(fvec)), sep = "")]
}
eval(action[[1]])
}
logic_map(fvec = replicate(20, sample(colors()[1:10], 2), simplify = FALSE), bvec = c(A = "ali", B = "aqu", C = "whi"), regex = TRUE)
# logic_map
logic_map <- function(fvec, avec = rep(1, length(fvec)), bvec = sort(unique(fvec)), logical.out = FALSE, regex = FALSE, chatty = FALSE){
#' Logical Test Occurrence Map
#'
#' \code{logic_map} conducts a test of a vector or list of tuples against a vector of unique values. The test can be one of \code{identity}, pattern-matching, or some custom function with Boolean output. Parallelism is supported with a registered \code{\link[foreach]{foreach}} backend.  If no backend is registered, \code{\link[foreach]{registerDoSEQ}} is used as a default.
#'
#' @param fvec (vector) Values to be tested: may be a simple vector or a list of tuples
#' @param avec (vector) Optional vector of numeric values to project \emph{a}cross the basis vector
#' @param bvec (vector) A vector of unique values forming the basis of comparison  If given as a named list, the output will preserve the names when creating columns; otherwise, the values of \code{bvec} are used as the names.
#'
#' @param logical.out (logical, vector) When \code{TRUE}, the output consists of logical values; when a vector of length two (2) is supplied, the first value returns on \code{FALSE}, the second on \code{TRUE}; otherwise, the values of \code{avec} are used.  If the vector form is used, only the first value at each position is used to supply the choices.
#' @param regex (logical | \code{FALSE}) When \code{TRUE}, argument \code{bvec} is interpreted as patterns against which case-sensitive matches are sought are attempted.  This forces the value of \code{test} to invoke \code{\link[data.table]{like}}.
#' @param chatty (logical | \code{FALSE}) When \code{TRUE}, additional information is printed to console
#'
#' @section \strong{Restriction}:
#' \code{length(fvec) == length(avec)}
#'
#' @section \strong{Warning}:
#' When combining with the source object, \code{fvec} must \strong{NOT} be sorted during the function call or the values will not map correctly in the output.
#'
#' @return Invisibly, a data.table object, the column names being the values of \code{bvec} or names of \code{bvec} if they exist
#'
#' @export
bvec <- sort(unique(unlist(bvec)));
if (is.null(names(bvec))){ names(bvec) <- bvec }
if (chatty){ print(list(fvec = c(fvec), avec = c(avec), bvec = bvec, out.names = out.names)) }
action <- { rlang::exprs(
# logical.out = TRUE; `==` ~ <default>
`100` = outer(fvec, bvec, `==`)
, # avec ~ logical.out = FALSE; `==` ~ <default>
`000` = outer(fvec, bvec, `==`) * avec
, # logical.out = TRUE, {purrr::map; `%in% } ~ fvec[]
`101` = purrr::map(fvec, ~rlang::set_names(bvec %in% .x, bvec)) |> purrr::reduce(rbind)
, # avec ~ logical.out = FALSE; {purrr::map; `%in% } ~ fvec[]
`001` = purrr::map(fvec, ~rlang::set_names(bvec %in% .x, bvec)) |> purrr::reduce(rbind) * avec
, # logical.out = TRUE; stringi::stri_detect_regex ~ regex
`110` = outer(fvec, bvec, stringi::stri_detect_regex)
, # avec ~ logical.out = FALSE; `stringi::stri_detect_regex ~ regex
`010` = outer(fvec, bvec, stringi::stri_detect_regex) * avec
, # logical.out = TRUE, stringi::stri_detect_regex ~ regex, {purrr::map; `%in% } ~ fvec[]
`111` = purrr::map(fvec, ~{ fv = .x; purrr::map_lgl(bvec, ~stringi::stri_detect_regex(fv, .x) |> any()) }) |>
purrr::reduce(rbind)
, # avec ~ logical.out = FALSE, stringi::stri_detect_regex ~ regex, {purrr::map; `%in% } ~ fvec[]
`011` = purrr::map(fvec, ~{ fv = .x; purrr::map_lgl(bvec, ~stringi::stri_detect_regex(fv, .x) |> any()) }) |>
purrr::reduce(rbind)* avec
)[paste(as.numeric(logical.out), as.numeric(regex), as.numeric(is.list(fvec)), sep = "")]
}
eval(action[[1]])
}
logic_map(fvec = replicate(20, sample(colors()[1:10], 2), simplify = FALSE), bvec = c(A = "ali", B = "aqu", C = "whi"), regex = TRUE)
logic_map(fvec = replicate(20, sample(colors()[1:10], 2), simplify = FALSE), bvec = c(A = "ali", B = "aqu", C = "whi"), regex = TRUE, logical.out = TRUE)
# logic_map
logic_map <- function(fvec, avec = rep(1, length(fvec)), bvec = sort(unique(fvec)), logical.out = FALSE, regex = FALSE, chatty = FALSE){
#' Logical Test Occurrence Map
#'
#' \code{logic_map} conducts a test of a vector or list of tuples against a vector of unique values. The test can be one of \code{identity}, pattern-matching, or some custom function with Boolean output. Parallelism is supported with a registered \code{\link[foreach]{foreach}} backend.  If no backend is registered, \code{\link[foreach]{registerDoSEQ}} is used as a default.
#'
#' @param fvec (vector) Values to be tested: may be a simple vector or a list of tuples
#' @param avec (vector) Optional vector of numeric values to project \emph{a}cross the result (must be the same length as \code{fvec} or length-1)
#' @param bvec (vector) A vector of unique values forming the basis of comparison  If given as a named list, the output will preserve the names when creating columns; otherwise, the values of \code{bvec} are used as the names.
#' @param logical.out (logical, vector) When \code{TRUE}, the output consists of logical values; when a vector of length two (2) is supplied, the first value returns on \code{FALSE}, the second on \code{TRUE}; otherwise, the values of \code{avec} are used.  If the vector form is used, only the first value at each position is used to supply the choices.
#' @param regex (logical | \code{FALSE}) When \code{TRUE}, argument \code{bvec} is interpreted as patterns against which case-sensitive matches are sought are attempted.  This forces the value of \code{test} to invoke \code{\link[data.table]{like}}.
#' @param chatty (logical | \code{FALSE}) When \code{TRUE}, additional information is printed to console
#'
#' @note \code{length(fvec) == length(avec)}
#'
#' @section \strong{Warning}:
#' When combining with the source object, \code{fvec} must \strong{NOT} be sorted during the function call or the values will not map correctly in the output.
#'
#' @return Invisibly, a data.table object, the column names being the values of \code{bvec} or names of \code{bvec} if they exist
#'
#' @export
bvec <- sort(unique(unlist(bvec)));
if (is.null(names(bvec))){ names(bvec) <- bvec }
if (chatty){ print(list(fvec = c(fvec), avec = c(avec), bvec = bvec, out.names = out.names)) }
action <- { rlang::exprs(
# logical.out = TRUE; `==` ~ <default>
`100` = outer(fvec, bvec, `==`)
, # avec ~ logical.out = FALSE; `==` ~ <default>
`000` = outer(fvec, bvec, `==`) * avec
, # logical.out = TRUE, {purrr::map; `%in% } ~ fvec[]
`101` = purrr::map(fvec, ~rlang::set_names(bvec %in% .x, bvec)) |> purrr::reduce(rbind)
, # avec ~ logical.out = FALSE; {purrr::map; `%in% } ~ fvec[]
`001` = purrr::map(fvec, ~rlang::set_names(bvec %in% .x, bvec)) |> purrr::reduce(rbind) * avec
, # logical.out = TRUE; stringi::stri_detect_regex ~ regex
`110` = outer(fvec, bvec, stringi::stri_detect_regex)
, # avec ~ logical.out = FALSE; `stringi::stri_detect_regex ~ regex
`010` = outer(fvec, bvec, stringi::stri_detect_regex) * avec
, # logical.out = TRUE, stringi::stri_detect_regex ~ regex, {purrr::map; `%in% } ~ fvec[]
`111` = purrr::map(fvec, ~{ fv = .x; purrr::map_lgl(bvec, ~stringi::stri_detect_regex(fv, .x) |> any()) }) |>
purrr::reduce(rbind)
, # avec ~ logical.out = FALSE, stringi::stri_detect_regex ~ regex, {purrr::map; `%in% } ~ fvec[]
`011` = purrr::map(fvec, ~{ fv = .x; purrr::map_lgl(bvec, ~stringi::stri_detect_regex(fv, .x) |> any()) }) |>
purrr::reduce(rbind)* avec
)[paste(as.numeric(logical.out), as.numeric(regex), as.numeric(is.list(fvec)), sep = "")]
}
eval(action[[1]])
}
(function(mapFields){ rlang::enexprs(mapFields) })(mapFields = c(col_1, col_2, col_3))
(function(mapFields){ rlang::enexprs(mapFields)[[1]] })(mapFields = c(col_1, col_2, col_3))
(function(mapFields){ rlang::enexprs(mapFields)[[1]] |> is.call() })(mapFields = c(col_1, col_2, col_3))
(function(mapFields){ rlang::enexprs(mapFields)[[1]] |> as.expression() })(mapFields = c(col_1, col_2, col_3))
(function(mapFields){ rlang::enexprs(mapFields)[[1]] |> as.expression() |> as.list() })(mapFields = c(col_1, col_2, col_3))
(function(mapFields){ rlang::enexprs(mapFields)[[1]] |> as.list() })(mapFields = c(col_1, col_2, col_3))
(function(mapFields){ rlang::enexprs(mapFields)[[1]] |> as.list() |> magrittr::extract2(1) })(mapFields = c(col_1, col_2, col_3))
(function(mapFields){ rlang::enexprs(mapFields)[[1]] |> as.list() |> magrittr::extract2(-1) })(mapFields = c(col_1, col_2, col_3))
(function(mapFields){ rlang::enexprs(mapFields)[[1]] |> as.list() |> `[[`(-1) })(mapFields = c(col_1, col_2, col_3))
(function(mapFields){`[[`( rlang::enexprs(mapFields)[[1]] |> as.list(), -1) })(mapFields = c(col_1, col_2, col_3))
(function(mapFields){ rlang::enexprs(mapFields)[[1]] |> as.list() |> magrittr::extract(-1) })(mapFields = c(col_1, col_2, col_3))
(function(map_fields, boundary_name){
rlang::enexprs(map_fields)[[1]] |> as.list() |> magrittr::extract(-1);
boundary_name	= as.character(rlang::enexpr(boundary_name));
})(
map_fields = c(col_1, col_2, col_3))
(function(map_fields, boundary_name){
map_fields = rlang::enexprs(map_fields)[[1]] |> as.list() |> magrittr::extract(-1);
boundary_name	= rlang::as_label(rlang::enexpr(boundary_name));
})(
map_fields = c(col_1, col_2, col_3)
boundary_name = episode
)
(function(map_fields, boundary_name){
map_fields = rlang::enexprs(map_fields)[[1]] |> as.list() |> magrittr::extract(-1);
boundary_name	= rlang::as_label(rlang::enexpr(boundary_name));
})(
map_fields = c(col_1, col_2, col_3)
, boundary_name = episode
)
(function(map_fields, boundary_name){
map_fields = rlang::enexprs(map_fields)[[1]] |> as.list() |> magrittr::extract(-1);
boundary_name	= rlang::as_label(rlang::enexpr(boundary_name));
mget(ls())
})(
map_fields = c(col_1, col_2, col_3)
, boundary_name = episode
)
# continuity ----
x <- data.table(
g = sample(LETTERS[1:4], 2000, TRUE)
, i = sample(100, 2000, TRUE)
)[, j := i + sample(100, 2000, TRUE)]
(function(data, map_fields, boundary_name){
data <- rlang::as_data_mask(data)
map_fields = rlang::enexprs(map_fields)[[1]] |> as.list() |> magrittr::extract(-1);
boundary_name	= rlang::as_label(rlang::enexpr(boundary_name));
mget(ls())
})(
x
, map_fields = c(col_1, col_2, col_3)
, boundary_name = episode
)
# continuity ----
x <- data.table(
g = sample(LETTERS[1:4], 2000, TRUE)
, i = sample(100, 2000, TRUE)
)[, j := i + sample(100, 2000, TRUE)]
# continuity ----
x <- data.table::data.table(
g = sample(LETTERS[1:4], 2000, TRUE)
, i = sample(100, 2000, TRUE)
)[, j := i + sample(100, 2000, TRUE)]
data.table::setorder(x, g, i, j)
(function(data, map_fields, boundary_name){
data <- rlang::as_data_mask(data)
map_fields = rlang::enexprs(map_fields)[[1]] |> as.list() |> magrittr::extract(-1);
boundary_name	= rlang::as_label(rlang::enexpr(boundary_name));
mget(ls())
})(
x
, map_fields = c(col_1, col_2, col_3)
, boundary_name = episode
)
(function(data, map_fields, boundary_name){
data <- rlang::as_data_mask(data)
map_fields <- rlang::enexprs(map_fields)[[1]] |> as.list() |> magrittr::extract(-1) |> rlang::as_quosures(env = data);
boundary_name	<- rlang::as_label(rlang::enexpr(boundary_name));
mget(ls())
})(
x
, map_fields = c(col_1, col_2, col_3)
, boundary_name = episode
)
inspect <- (function(data, map_fields, boundary_name){
data <- rlang::as_data_mask(data)
map_fields <- rlang::enexprs(map_fields)[[1]] |> as.list() |> magrittr::extract(-1) |> rlang::as_quosures(env = data);
boundary_name	<- rlang::as_label(rlang::enexpr(boundary_name));
mget(ls())
})(
x
, map_fields = c(col_1, col_2, col_3)
, boundary_name = episode
)
inspect$map_fields |> rlang::eval_tidy()
rlang::eval_tidy(inspect$map_fields)
rlang::eval_tidy(!!inspect$map_fields)
rlang::eval_tidy(!!!inspect$map_fields)
inspect$map_fields |> lapply(rlang::eval_tidy)
inspect$map_fields |> purrr::map(~.data$col_1)
inspect$map_fields |> purrr::map(~$col_1)
inspect$map_fields |> purrr::map(~col_1)
inspect$map_fields |> purrr::map(~rlang::eval_tidy(.x))
inspect$map_fields |> purrr::map(~rlang::eval_tidy(.x, env = rlang::quo_get_env(.x)))
inspect <- (function(data, map_fields, boundary_name){
map_fields <- rlang::enexprs(map_fields)[[1]] |> as.list() |> magrittr::extract(-1);
boundary_name	<- rlang::as_label(rlang::enexpr(boundary_name));
mget(ls())
})(
x
, map_fields = c(col_1, col_2, col_3)
, boundary_name = episode
)
inspect <- (function(data, map_fields, boundary_name){
data <- rlang::as_data_mask(data)
map_fields <- rlang::enexprs(map_fields)[[1]] |> as.list() |> magrittr::extract(-1) |> rlang::as_quosures(env = data);
boundary_name	<- rlang::as_label(rlang::enexpr(boundary_name));
mget(ls())
})(
x
, map_fields = c(g)
, boundary_name = episode
)
inspect$map_fields |> purrr::map(~rlang::eval_tidy(.x))
inspect$map_fields |> rlang::eval_tidy()
inspect$map_fields |> purrr::map(~rlang::eval_tidy(.x))
inspect <- (function(data, map_fields, boundary_name){
data <- rlang::as_data_mask(data)
rlang::enexprs(map_fields, .named = TRUE)[[1]] |>
as.list() |>
magrittr::extract(-1) |>
rlang::as_quosures(env = data, named = TRUE) |>
list2env(envir = environment())
boundary_name	<- rlang::as_label(rlang::enexpr(boundary_name));
mget(ls())
})(
x
, map_fields = c(g)
, boundary_name = episode
)
test_fun <- function(data, map_fields, boundary_name){
data <- rlang::as_data_mask(data)
rlang::enexprs(map_fields, .named = TRUE)[[1]] |>
as.list() |>
magrittr::extract(-1) |>
rlang::as_quosures(env = data, named = TRUE) |>
list2env(envir = environment())
boundary_name	<- rlang::as_label(rlang::enexpr(boundary_name));
mget(ls())
}
inspect <- test_fun(x, map_fields = c(g), boundary_name = episode)
debug(test_fun)
inspect <- test_fun(x, map_fields = c(g), boundary_name = episode)
test_fun <- function(data, map_fields, boundary_name){
data <- rlang::as_data_mask(data)
rlang::enexprs(map_fields, .named = TRUE)[[1]] |>
as.list() |>
magrittr::extract(-1) |>
purrr::map(~rlang::as_quosures(.x, env = data, named = TRUE)) |>
list2env(envir = environment())
boundary_name	<- rlang::as_label(rlang::enexpr(boundary_name));
mget(ls())
}
debug(test_fun)
inspect <- test_fun(x, map_fields = c(g), boundary_name = episode)
rlang::enexprs(map_fields, .named = TRUE)[[1]] |>
as.list() |>
magrittr::extract(-1) |>
purrr::map(~rlang::as_quosures(.x, env = data, named = TRUE))
inspect <- test_fun(x, map_fields = c(g), boundary_name = episode)
test_fun <- function(data, map_fields, boundary_name){
data <- rlang::as_data_mask(data)
rlang::enexprs(map_fields, .named = TRUE)[[1]] |>
as.list() |>
magrittr::extract(-1) |>
purrr::map(~rlang::as_quosures(.x, env = data, named = TRUE))
boundary_name	<- rlang::as_label(rlang::enexpr(boundary_name));
mget(ls())
}
debug(test_fun)
inspect <- test_fun(x, map_fields = c(g), boundary_name = episode)
function(data, map_fields, boundary_name){
data <- rlang::as_data_mask(data)
rlang::enexprs(map_fields, .named = TRUE)[[1]] |>
as.list() |>
magrittr::extract(-1) |>
purrr::map(~rlang::as_quosures(.x, env = data, named = TRUE))
boundary_name	<- rlang::as_label(rlang::enexpr(boundary_name));
mget(ls())
}
test_fun <- function(data, map_fields, boundary_name){
data <- rlang::as_data_mask(data)
map_fields <- rlang::enexprs(map_fields, .named = TRUE)
map_fields[[1]] |>
as.list()
magrittr::extract(-1) |>
purrr::map(~rlang::as_quosures(.x, env = data, named = TRUE))
# |>
# list2env(envir = environment())
boundary_name	<- rlang::as_label(rlang::enexpr(boundary_name));
mget(ls())
}
debug(test_fun)
inspect <- test_fun(x, map_fields = c(g), boundary_name = episode)
test_fun <- function(data, map_fields, boundary_name){
data <- rlang::as_data_mask(data)
map_fields <- rlang::enexprs(map_fields, .named = TRUE)
map_fields[[1]] |>
as.list() |>
magrittr::extract(-1) |>
purrr::map(~rlang::as_quosures(.x, env = data, named = TRUE))
# |>
# list2env(envir = environment())
boundary_name	<- rlang::as_label(rlang::enexpr(boundary_name));
mget(ls())
}
debug(test_fun)
inspect <- test_fun(x, map_fields = c(g), boundary_name = episode)
}
test_fun <- function(data, map_fields, boundary_name){
data <- rlang::as_data_mask(data)
map_fields <- rlang::enexprs(map_fields, .named = TRUE)
map_fields[[1]] |>
as.list() |>
magrittr::extract(-1) |>
purrr::map(~rlang::as_quosures(.x, env = data, named = TRUE)) |>
list2env(envir = environment())
boundary_name	<- rlang::as_label(rlang::enexpr(boundary_name));
mget(ls())
}
debug(test_fun)
inspect <- test_fun(x, map_fields = c(g), boundary_name = episode)
function(data, map_fields, boundary_name){
data <- rlang::as_data_mask(data)
map_fields <- rlang::enexprs(map_fields, .named = TRUE)
map_fields[[1]] |>
as.list() |>
magrittr::extract(-1) |>
purrr::map(~rlang::as_quosures(.x, env = data, named = TRUE)) |>
list2env(envir = environment())
boundary_name	<- rlang::as_label(rlang::enexpr(boundary_name));
mget(ls())
}
test_fun <- function(data, map_fields, boundary_name){
data <- rlang::as_data_mask(data)
map_fields <- rlang::enexprs(map_fields, .named = TRUE) |>
magrittr::extract2(-1) |>
as.list() |>
magrittr::extract(-1)
purrr::map(map_fields, ~rlang::as_quosures(.x, env = data, named = TRUE)) |>
list2env(envir = environment())
boundary_name	<- rlang::as_label(rlang::enexpr(boundary_name));
mget(ls())
}
debug(test_fun)
inspect <- test_fun(x, map_fields = c(g), boundary_name = episode)
test_fun <- function(data, map_fields, boundary_name){
data <- rlang::as_data_mask(data)
map_fields <- rlang::enexprs(map_fields, .named = TRUE) |>
magrittr::extract(-1) |>
as.list() |>
magrittr::extract(-1)
purrr::map(map_fields, ~rlang::as_quosures(.x, env = data, named = TRUE)) |>
list2env(envir = environment())
boundary_name	<- rlang::as_label(rlang::enexpr(boundary_name));
mget(ls())
}
debug(test_fun)
inspect <- test_fun(x, map_fields = c(g), boundary_name = episode)
function(data, map_fields, boundary_name){
data <- rlang::as_data_mask(data)
map_fields <- rlang::enexprs(map_fields, .named = TRUE) |>
magrittr::extract(-1) |>
as.list() |>
magrittr::extract(-1)
purrr::map(map_fields, ~rlang::as_quosures(.x, env = data, named = TRUE)) |>
list2env(envir = environment())
boundary_name	<- rlang::as_label(rlang::enexpr(boundary_name));
mget(ls())
}
test_fun <- function(data, map_fields, boundary_name){
data <- rlang::as_data_mask(data)
map_fields <- rlang::enexprs(map_fields, .named = TRUE)
as.list() |>
magrittr::extract(-1)
purrr::map(map_fields, ~rlang::as_quosures(.x, env = data, named = TRUE)) |>
list2env(envir = environment())
boundary_name	<- rlang::as_label(rlang::enexpr(boundary_name));
mget(ls())
}
debug(test_fun)
inspect <- test_fun(x, map_fields = c(g), boundary_name = episode)
test_fun <- function(data, map_fields, boundary_name){
data <- rlang::as_data_mask(data)
map_fields <- rlang::enexprs(map_fields, .named = TRUE) |>
as.list() |>
magrittr::extract(-1)
purrr::map(map_fields, ~rlang::as_quosures(.x, env = data, named = TRUE)) |>
list2env(envir = environment())
boundary_name	<- rlang::as_label(rlang::enexpr(boundary_name));
mget(ls())
}
debug(test_fun)
inspect <- test_fun(x, map_fields = c(g), boundary_name = episode)
test_fun <- function(data, map_fields, boundary_name){
data <- rlang::as_data_mask(data)
map_fields <- rlang::enexprs(map_fields, .named = TRUE) |>
as.list()
# magrittr::extract(-1)
purrr::map(map_fields, ~rlang::as_quosures(.x, env = data, named = TRUE)) |>
list2env(envir = environment())
boundary_name	<- rlang::as_label(rlang::enexpr(boundary_name));
mget(ls())
}
debug(test_fun)
inspect <- test_fun(x, map_fields = c(g), boundary_name = episode)
test_fun <- function(data, map_fields, boundary_name){
data <- rlang::as_data_mask(data)
map_fields <- rlang::enexprs(map_fields, .named = TRUE) |>
magrittr::extract2(-1) |>
as.list()
# magrittr::extract(-1)
purrr::map(map_fields, ~rlang::as_quosures(.x, env = data, named = TRUE)) |>
list2env(envir = environment())
boundary_name	<- rlang::as_label(rlang::enexpr(boundary_name));
mget(ls())
}
debug(test_fun)
inspect <- test_fun(x, map_fields = c(g), boundary_name = episode)
test_fun <- function(data, map_fields, boundary_name){
data <- rlang::as_data_mask(data)
map_fields <- rlang::enexprs(map_fields, .named = TRUE) |>
magrittr::extract2(1) |>
as.list() |>
magrittr::extract(-1)
purrr::map(map_fields, ~rlang::as_quosures(.x, env = data, named = TRUE)) |>
list2env(envir = environment())
boundary_name	<- rlang::as_label(rlang::enexpr(boundary_name));
mget(ls())
}
debug(test_fun)
inspect <- test_fun(x, map_fields = c(g), boundary_name = episode)
inspect <- test_fun(x, map_fields = c(g), boundary_name = episode)
purrr::map(map_fields, ~rlang::as_quosures(.x, env = data, named = TRUE))
test_fun <- function(data, map_fields, boundary_name){
data <- rlang::as_data_mask(data)
map_fields <- rlang::enexprs(map_fields, .named = TRUE) |>
magrittr::extract2(1) |>
as.list() |>
magrittr::extract(-1)
purrr::map(map_fields, ~rlang::as_quosures(.x, env = data, named = TRUE)) |>
magrittr::extract2(1) |>
list2env(envir = environment())
boundary_name	<- rlang::as_label(rlang::enexpr(boundary_name));
mget(ls())
}
# debug(test_fun)
inspect <- test_fun(x, map_fields = c(g), boundary_name = episode)
View(inspect)
test_fun <- function(data, map_fields, boundary_name){
data <- rlang::as_data_mask(data)
map_fields <- rlang::enexprs(map_fields, .named = TRUE) |>
magrittr::extract2(1) |>
as.list() |>
magrittr::extract(-1)
purrr::iwalk(map_fields, ~{
assign(.y, rlang::inject(function(){
rlang::as_quosures(!!.x, env = !!data, named = TRUE))
}, env = environment())
})
boundary_name	<- rlang::as_label(rlang::enexpr(boundary_name));
mget(ls())
}
# debug(test_fun)
inspect <- test_fun(x, map_fields = c(g), boundary_name = episode)
test_fun <- function(data, map_fields, boundary_name){
data <- rlang::as_data_mask(data)
map_fields <- rlang::enexprs(map_fields, .named = TRUE) |>
magrittr::extract2(1) |>
as.list() |>
magrittr::extract(-1) |>
purrr::map(~rlang::as_quosures(.x, env = data, named = TRUE))
boundary_name	<- rlang::as_label(rlang::enexpr(boundary_name));
mget(ls())
}
# debug(test_fun)
inspect <- test_fun(x, map_fields = c(g), boundary_name = episode)
inspect$map_fields |> purrr::map(~rlang::eval_tidy(.x))
