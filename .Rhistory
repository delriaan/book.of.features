#' \code{make.windows} is a wrapper for \code{\link[slider]{slider}}
#'
#' @param series A list or vector object from which incremental subsets (windows) of a fixed size are chosen
#' @param window.size (integer) The size of the subset (window) to select
#' @param increment (integer) The number of elements by which iteration should advance
#' @param post (function) A post-processing function on the return object having class "data.table" and single column "window"
#' @param debug (logical | FALSE) When \code{TRUE}, additional information is printed to console for debugging purposes
#' @param ... Additional arguments sent to  \code{\link[slider]{slider}}
#'
#' Sets are the result of forward-moving partitioning:
#' \enumerate{
#'   \item \code{window.size}: The size of each partition (W)
#'   \item \code{increment}: The number of items to increment before selecting the next W items (W + i)
#' }
#'
#' @return A serialized collection-list of partitions (windows), each window containing a subset of size \code{window.size}
#'
#' @family Data Generation
#'
#' @export
slider::slide(
.x = series
, .f = post
, .before = ifelse(rlang::is_empty(list(...)[[".after"]]), window.size[1], list(...)[[".after"]])
, .after = ifelse(rlang::is_empty(list(...)[[".before"]]), window.size[1], list(...)[[".before"]])
, .step = increment
, ...
)
}
# debug(make.windows)
make.windows(
series = c(1:100)
, window.size = 2
, increment = 2
)
#
make.windows <- function(series, window.size, increment = 1, post = eval, debug = FALSE, ...) {
#' Serial Window Maker (DEPRECATED)
#'
#' \code{make.windows} is a wrapper for \code{\link[slider]{slider}}
#'
#' @param series A list or vector object from which incremental subsets (windows) of a fixed size are chosen
#' @param window.size (integer) The size of the subset (window) to select
#' @param increment (integer) The number of elements by which iteration should advance
#' @param post (function) A post-processing function on the return object having class "data.table" and single column "window"
#' @param debug (logical | FALSE) When \code{TRUE}, additional information is printed to console for debugging purposes
#' @param ... Additional arguments sent to  \code{\link[slider]{slider}}
#'
#' Sets are the result of forward-moving partitioning:
#' \enumerate{
#'   \item \code{window.size}: The size of each partition (W)
#'   \item \code{increment}: The number of items to increment before selecting the next W items (W + i)
#' }
#'
#' @return A serialized collection-list of partitions (windows), each window containing a subset of size \code{window.size}
#'
#' @family Data Generation
#'
#' @export
slider::slide(
.x = series
, .f = post
, .before = ifelse(rlang::is_empty(list(...)[[".before"]]), 0L, window.size)
, .after = ifelse(rlang::is_empty(list(...)[[".after"]]), 0L, window.size)
, .step = increment
, ...
)
}
# debug(make.windows)
make.windows(
series = c(1:100)
, window.size = 2
, increment = 2
)
c(1:100)
#
make.windows <- function(series, window.size, increment = 1, post = eval, debug = FALSE, ...) {
#' Serial Window Maker (DEPRECATED)
#'
#' \code{make.windows} is a wrapper for \code{\link[slider]{slider}}
#'
#' @param series A list or vector object from which incremental subsets (windows) of a fixed size are chosen
#' @param window.size (integer) The size of the subset (window) to select
#' @param increment (integer) The number of elements by which iteration should advance
#' @param post (function) A post-processing function on the return object having class "data.table" and single column "window"
#' @param debug (logical | FALSE) When \code{TRUE}, additional information is printed to console for debugging purposes
#' @param ... Additional arguments sent to  \code{\link[slider]{slider}}
#'
#' Sets are the result of forward-moving partitioning:
#' \enumerate{
#'   \item \code{window.size}: The size of each partition (W)
#'   \item \code{increment}: The number of items to increment before selecting the next W items (W + i)
#' }
#'
#' @return A serialized collection-list of partitions (windows), each window containing a subset of size \code{window.size}
#'
#' @family Data Generation
#'
#' @export
slider::slide(
.x = series
, .f = post
, .before = ifelse(window.size < 0L, window.size, 0L)
, .after = ifelse(window.size > 0L, window.size, 0L)
, .step = increment
, ...
)
}
# debug(make.windows)
make.windows(
series = c(1:100)
, window.size = 2
, increment = 2
)
# debug(make.windows)
make.windows(
series = c(1:100)
, window.size = 2
, increment = 1
)
#
make.windows <- function(series, window.size, increment = 1, post = eval, debug = FALSE, ...) {
#' Serial Window Maker (DEPRECATED)
#'
#' \code{make.windows} is a wrapper for \code{\link[slider]{slider}}
#'
#' @param series A list or vector object from which incremental subsets (windows) of a fixed size are chosen
#' @param window.size (integer) The size of the subset (window) to select
#' @param increment (integer) The number of elements by which iteration should advance
#' @param post (function) A post-processing function on the return object having class "data.table" and single column "window"
#' @param debug (logical | FALSE) When \code{TRUE}, additional information is printed to console for debugging purposes
#' @param ... Additional arguments sent to  \code{\link[slider]{slider}}
#'
#' Sets are the result of forward-moving partitioning:
#' \enumerate{
#'   \item \code{window.size}: The size of each partition (W)
#'   \item \code{increment}: The number of items to increment before selecting the next W items (W + i)
#' }
#'
#' @return A serialized collection-list of partitions (windows), each window containing a subset of size \code{window.size}
#'
#' @family Data Generation
#'
#' @export
slider::slide(
.x = series
, .f = post
, .before = ifelse(window.size < 0L, window.size - 1, 0L)
, .after = ifelse(window.size > 0L, window.size - 1, 0L)
, .step = increment
, ...
)
}
# debug(make.windows)
make.windows(
series = c(1:100)
, window.size = 2
, increment = 1
)
make.windows(c(1:100), 2, 2)
make.windows(series = c(1:100), window.size = 2, increment = 2)
make.windows(c(1:100), 7, 5, .complete = TRUE)
make.windows(c(1:100), 7, 1, .complete = TRUE)
#
make.windows <- function(series, window.size, increment = 1, post = eval, debug = FALSE, ...) {
#' Serial Window Maker (DEPRECATED)
#'
#' \code{make.windows} is a wrapper for \code{\link[slider]{slider}}
#'
#' @param series A list or vector object from which incremental subsets (windows) of a fixed size are chosen
#' @param window.size (integer) The size of the subset (window) to select
#' @param increment (integer) The number of elements by which iteration should advance
#' @param post (function) A post-processing function on the return object having class "data.table" and single column "window"
#' @param debug (logical | FALSE) When \code{TRUE}, additional information is printed to console for debugging purposes
#' @param ... Additional arguments sent to  \code{\link[slider]{slider}}
#'
#' Sets are the result of forward-moving partitioning:
#' \enumerate{
#'   \item \code{window.size}: The size of each partition (W)
#'   \item \code{increment}: The number of items to increment before selecting the next W items (W + i)
#' }
#'
#' @return A serialized collection-list of partitions (windows), each window containing a subset of size \code{window.size}
#'
#' @family Data Generation
#'
#' @export
slider::slide(
.x = series
, .f = post
, .before = ifelse(window.size < 0L, window.size - 1, 0L)
, .after = ifelse(window.size > 0L, window.size - 1, 0L)
, .step = increment
, ...
) |>
purrr::compact()
}
make.windows(c(1:100), 7, 1, .complete = TRUE)
make.windows(series = c(1:100), window.size = 2, increment = 2)
# debug(make.windows)
make.windows(
series = c(1:100)
, window.size = 2
, increment = 1
)
#
bin.windows <- function(i = 1, use.bin = NULL, min.factor = 1, as.factor = FALSE){
#' Create Bins From Integer Factor
#'
#' \code{bin.windows} creates binned ranges based on the minimum factor of the integer input (\code{i}) or user-supplied value.
#'
#' @param i (integer[]) An integer scalar, vector, or n-dimensional object executed conditionally as follows:
#' \itemize{
#' \item if a vector of length = 1, a zero-based sequence up to \code{abs(i) } is used
#' \item if a vector of length = 2, a sequence is created from the values in the order given
#' \item if a vector of length >= 3, the raw values
#' \item if n-dimensional, recursion along the last dimension given by \code{dim(i)} until a vector is detected
#' }
#'
#' @param use.bin (integer) The bin size to use: should be greater than zero (0), overrides the internal effects of argument \code{min.factor}.
#'
#' @param min.factor (integer) The minimum factor of of \code{i} allowed when \code{use.bin} is less than or equal to one (1).  This becomes the bin size.
#' @param as.factor (logical) Should the output be converted into a factor?
#'
#' @return A character (or factor) vector the length of the input, as "binned" representations.  If the input is dimensional, an array of the same dimensions is returned
#'
#' @family Data Generation
#'
#' @export
.dir <- FALSE;
func = function(ii)	{
ii <- as.integer(ii)
j <- if (rlang::has_length(ii, 1)){ 0:abs(ii)
} else if (rlang::has_length(ii, 2)){
.dir <- ii[2] < ii[1]; seq(ii[1], ii[2], by = sign(ii[2]-ii[1]))
} else { ii }
this.bin = if (rlang::is_empty(use.bin)){
factor.int(max(i, na.rm = TRUE)) %>% purrr::keep(~(.x >= min.factor)|(rlang::has_length(i, 2)))
} else { unique(sort(j %bin% use.bin)) }
.map = c(-Inf
, min(this.bin, na.rm = TRUE) - 1
, this.bin
, suppressWarnings(purrr::keep(diff(this.bin) + this.bin + 1, ~.x <= max(this.bin, na.rm = TRUE)))
, max(this.bin, na.rm = TRUE) + 1
, Inf
) %>%
sort(decreasing = .dir) %>%
make.windows(window.size = 2, increment = 2) %>%
data.table::data.table(purrr::map(., ~{
ifelse(
any(is.infinite(.x))
, ifelse(
.x[which(is.infinite(.x))] > 0
, c(">", "="[rlang::is_empty(use.bin)], " ") %>%
paste(collapse = "") %s+% max(.x[!is.infinite(.x)])
, c("<", "="[rlang::is_empty(use.bin)], " ") %>%
paste(collapse = "") %s+% min(.x[!is.infinite(.x)])
)
, paste(unlist(.x), collapse = " to ")
)
})) %>%
data.table::setnames(c("win.vals", "label"));
.out = purrr::map_chr(j, ~{
.val = .x;
.label = .map[, label[[which(purrr::map_lgl(win.vals, ~(.val %between% as.list(sort(.x)))))]]]
if (identical(.label, character())){ "oob"} else { .label }
});
if (as.factor){ .out <- factor(.out, levels = .map$label, ordered = TRUE) }
attr(.out, "bin.map") <- .map
.out
}
if (rlang::is_empty(dim(i)) | rlang::has_length(dim(i), 1)){
func(as.vector(i))
} else {
.dns = dimnames(i);
.dms = dim(i);
.out = apply(X = i, MARGIN = length(.dms), FUN = bin.windows
, use.bin = use.bin, min.factor = min.factor, as.factor = as.factor, simplify = TRUE);
if (length(.dms) == 2){ .out <- t(.out) }
as.array(.out) %>% structure(dim = .dms, dimnames = .dns);
}
}
bin.windows(i = 10)
# ::::: VALIDATION :::::
library(book.of.utilities, include.only = c("%bin%", "%::%", "%?%", "%??%", "factor.int")
library(magrittr, include.only = c("%>%")
# ::::: VALIDATION :::::
library(book.of.utilities, include.only = c("%bin%", "%::%", "%?%", "%??%", "factor.int"))
library(data.table, include.only = c("%like%", "%ilike%", "like", " %between%"))
library(data.table, include.only = c("%like%", "%ilike%", "like", "%between%"))
library(magrittr, include.only = c("%>%"))
library(stringi, include.only = c("%s+%"))
library(foreach, include.only = c("%do%", "%dopar%"))
bin.windows(i = 10)
bin.windows(i = 10, as.factor = TRUE)
bin.windows(c(5, 50), use.bin = 3)
bin.windows(c(5, 50), use.bin = 3, as.factor = TRUE)
bin.windows(array(1:10, dim = 10), use.bin = 3)
bin.windows(array(1:10, dim = 10), use.bin = 3, as.factor = TRUE)
X <- cbind(
a = sample(70, 30)
, b = sample(100, 30)
, c = sample(10, 30, TRUE)
) |> as.array() |> bin.windows(use.bin = 7)
dim(X)
X
#
bin.windows <- function(i = 1, use.bin = NULL, as.factor = FALSE, min.factor = 1){
#' Create Bins From Integer Factor
#'
#' \code{bin.windows} creates binned ranges based on the minimum factor of the integer input (\code{i}) or user-supplied value.
#'
#' @param i (integer[]) An integer scalar, vector, or n-dimensional object executed conditionally as follows:
#' \itemize{
#' \item if a vector of length = 1, a zero-based sequence up to \code{abs(i) } is used
#' \item if a vector of length = 2, a sequence is created from the values in the order given
#' \item if a vector of length >= 3, the raw values
#' \item if n-dimensional, recursion along the last dimension given by \code{dim(i)} until a vector is detected
#' }
#'
#' @param use.bin (integer) The bin size to use: should be greater than zero (0), overrides the internal effects of argument \code{min.factor}.
#'
#' @param as.factor (logical) Should the output be converted into a factor?
#'
#' @param min.factor (integer) The minimum factor of of \code{i} allowed when \code{use.bin} is less than or equal to one (1).  This becomes the bin size.
#'
#' @return A character (or factor) vector the length of the input, as "binned" representations.  If the input is dimensional, an array of the same dimensions is returned
#'
#' @family Data Generation
#'
#' @export
.dir <- FALSE;
func = function(ii)	{
ii <- as.integer(ii)
j <- if (rlang::has_length(ii, 1)){ 0:abs(ii)
} else if (rlang::has_length(ii, 2)){
.dir <- ii[2] < ii[1]; seq(ii[1], ii[2], by = sign(ii[2]-ii[1]))
} else { ii }
this.bin = if (rlang::is_empty(use.bin)){
factor.int(max(i, na.rm = TRUE)) %>% purrr::keep(~(.x >= min.factor)|(rlang::has_length(i, 2)))
} else { unique(sort(j %bin% use.bin)) }
.map = c(-Inf
, min(this.bin, na.rm = TRUE) - 1
, this.bin
, suppressWarnings(purrr::keep(diff(this.bin) + this.bin + 1, ~.x <= max(this.bin, na.rm = TRUE)))
, max(this.bin, na.rm = TRUE) + 1
, Inf
) |>
sort(decreasing = .dir) |>
make.windows(window.size = 2, increment = 2) %>%
data.table::data.table(purrr::map(., ~{
ifelse(
any(is.infinite(.x))
, ifelse(
.x[which(is.infinite(.x))] > 0
, c(">", "="[rlang::is_empty(use.bin)], " ") |>
paste(collapse = "") %s+% max(.x[!is.infinite(.x)])
, c("<", "="[rlang::is_empty(use.bin)], " ") |>
paste(collapse = "") %s+% min(.x[!is.infinite(.x)])
)
, paste(unlist(.x), collapse = " to ")
)
})) |>
data.table::setnames(c("win.vals", "label"));
.out = purrr::map_chr(j, ~{
.val = .x;
.label = .map[, label[[which(purrr::map_lgl(win.vals, ~(.val %between% as.list(sort(.x)))))]]]
if (identical(.label, character())){ "oob"} else { .label }
});
if (as.factor){ .out <- factor(.out, levels = .map$label, ordered = TRUE) }
attr(.out, "bin.map") <- .map
.out
}
if (rlang::is_empty(dim(i)) | rlang::has_length(dim(i), 1)){
func(as.vector(i))
} else {
.dns = dimnames(i);
.dms = dim(i);
.out = apply(X = i, MARGIN = length(.dms), FUN = bin.windows
, use.bin = use.bin, min.factor = min.factor, as.factor = as.factor, simplify = TRUE);
if (length(.dms) == 2){ .out <- t(.out) }
as.array(.out) %>% structure(dim = .dms, dimnames = .dns);
}
}
X <- cbind(
a = sample(70, 30)
, b = sample(100, 30)
, c = sample(10, 30, TRUE)
) |> as.array() |> bin.windows(use.bin = 7, as.factor = TRUE)
dim(X)
X
View(X)
#
bin.windows <- function(i = 1, use.bin = NULL, as.factor = FALSE, min.factor = 1){
#' Create Bins From Integer Factor
#'
#' \code{bin.windows} creates binned ranges based on the minimum factor of the integer input (\code{i}) or user-supplied value.
#'
#' @param i (integer[]) An integer scalar, vector, or n-dimensional object executed conditionally as follows:
#' \itemize{
#' \item if a vector of length = 1, a zero-based sequence up to \code{abs(i) } is used
#' \item if a vector of length = 2, a sequence is created from the values in the order given
#' \item if a vector of length >= 3, the raw values
#' \item if n-dimensional, recursion along the last dimension given by \code{dim(i)} until a vector is detected
#' }
#'
#' @param use.bin (integer) The bin size to use: should be greater than zero (0), overrides the internal effects of argument \code{min.factor}.
#'
#' @param as.factor (logical) Should the output be converted into a factor?
#'
#' @param min.factor (integer) The minimum factor of of \code{i} allowed when \code{use.bin} is less than or equal to one (1).  This becomes the bin size.
#'
#' @return A character (or factor) vector the length of the input, as "binned" representations.  If the input is dimensional, an array of the same dimensions is returned
#'
#' @family Data Generation
#'
#' @export
.dir <- FALSE;
func = function(ii)	{
ii <- as.integer(ii)
j <- if (rlang::has_length(ii, 1)){ 0:abs(ii)
} else if (rlang::has_length(ii, 2)){
.dir <- ii[2] < ii[1]; seq(ii[1], ii[2], by = sign(ii[2]-ii[1]))
} else { ii }
this.bin = if (rlang::is_empty(use.bin)){
factor.int(max(i, na.rm = TRUE)) %>% purrr::keep(~(.x >= min.factor)|(rlang::has_length(i, 2)))
} else { unique(sort(j %bin% use.bin)) }
.map = c(-Inf
, min(this.bin, na.rm = TRUE) - 1
, this.bin
, suppressWarnings(purrr::keep(diff(this.bin) + this.bin + 1, ~.x <= max(this.bin, na.rm = TRUE)))
, max(this.bin, na.rm = TRUE) + 1
, Inf
) |>
sort(decreasing = .dir) |>
make.windows(window.size = 2, increment = 2) %>%
data.table::data.table(purrr::map(., ~{
ifelse(
any(is.infinite(.x))
, ifelse(
.x[which(is.infinite(.x))] > 0
, c(">", "="[rlang::is_empty(use.bin)], " ") |>
paste(collapse = "") %s+% max(.x[!is.infinite(.x)])
, c("<", "="[rlang::is_empty(use.bin)], " ") |>
paste(collapse = "") %s+% min(.x[!is.infinite(.x)])
)
, paste(unlist(.x), collapse = " to ")
)
})) |>
data.table::setnames(c("win.vals", "label"));
.out = purrr::map_chr(j, ~{
.val = .x;
.label = .map[, label[[which(purrr::map_lgl(win.vals, ~(.val %between% as.list(sort(.x)))))]]]
if (identical(.label, character())){ "oob"} else { .label }
});
attr(.out, "bin.map") <- .map
.out
}
if (rlang::is_empty(dim(i)) | rlang::has_length(dim(i), 1)){
.out = func(as.vector(i))
if (as.factor){ factor(.out, levels = attr(.out, "bin.map")$label, ordered = TRUE) } else { .out }
} else {
.dns = dimnames(i);
.dms = dim(i);
.out = apply(X = i, MARGIN = length(.dms), FUN = bin.windows
, use.bin = use.bin, min.factor = min.factor, as.factor = as.factor, simplify = TRUE);
if (length(.dms) == 2){ .out <- t(.out) }
as.array(.out) %>% structure(dim = .dms, dimnames = .dns);
}
}
X <- cbind(
a = sample(70, 30)
, b = sample(100, 30)
, c = sample(10, 30, TRUE)
) |> as.array() |> bin.windows(use.bin = 7, as.factor = TRUE)
dim(X)
X
X |> str()
X <- cbind(
a = sample(70, 30)
, b = sample(100, 30)
, c = sample(10, 30, TRUE)
) |> as.array() |> bin.windows(use.bin = 7, as.factor = TRUE)
X |> str()
apply(X, 2, as.factor)
apply(X, 2, as.factor) |> str()
X <- bin.windows(
i = array(data = sample(100:200, 60)
, dim = c(10, 2, 3)
, dimnames = purrr::map2(c(10, 2, 3), LETTERS[1:3], ~rep.int(.y, .x))
)
, use.bin = 7
, as.factor = TRUE
)
dim(X)
X[1,1,]
X[1,2,]
X[,,2]
X[1,2,3]
X <- bin.windows(array(sample(50:500, 120), dim = c(5, 4, 3, 2), dimnames = purrr::map2(c(5, 4, 3, 2), LETTERS[1:4], ~rep.int(.y, .x))), use.bin = 20)
dim(X)
X[1,1,,]
X[3,2,3, ]
X[,,3,1]
X[5,2,3, 1]
View(continuity)
# undebug(bin.windows)
# pkgdown::build_site()
library(book.of.features)
pkgdown::build_site()
library(book.of.features)
pkgdown::build_site()
