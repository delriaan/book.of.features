, type = "scatter", mode = "markers", name = .x
)
})
x <- sample(1000, 100)/1000
p <- plotly::plot_ly()
purrr::map(
c("guder", "logis", "atan"), ~{
y = do.call(sigmoid
, args = list(input = seq_along(x), family = .x, k = 0.2, center = median))
p <<- plotly::add_trace(
p = p, x = x, y = y
, hovertext = sprintf("x: %s\ny: %s", x, y)
, type = "scatter", mode = "markers", name = .x
)
})
sigmoid(x, family = "log")
data.frame(x = x, y = sigmoid(x, family = "log"))
x <- sample(1000, 100)/1000 |> sort()
data.frame(x = x, y = sigmoid(x, family = "log"))
x <- sample(1000, 100)/1000
x <- sort(x)
p <- plotly::plot_ly()
data.frame(x = x, y = sigmoid(x, family = "log"))
purrr::map(
c("guder", "logis", "atan"), ~{
y = do.call(sigmoid
, args = list(input = seq_along(x), family = .x, k = 0.2, center = median))
p <<- plotly::add_trace(
p = p, x = x, y = y
, hovertext = sprintf("x: %s\ny: %s", x, y)
, type = "scatter", mode = "markers", name = .x
)
})
purrr::map(
c("guder", "logis", "atan", "tanh", "gen"), ~{
y = do.call(sigmoid
, args = list(input = seq_along(x), family = .x, k = 0.2, center = median))
p <<- plotly::add_trace(
p = p, x = x, y = y
, hovertext = sprintf("x: %s\ny: %s", x, y)
, type = "scatter", mode = "markers", name = .x
)
})
purrr::map(
c("guder", "logis", "atan", "tanh", "gen"), ~{
y = do.call(sigmoid
, args = list(input = seq_along(x), family = .x, k = 0.2, center = median))
p <<- plotly::add_trace(
p = p, x = x, y = y
, hovertext = sprintf("x: %s\ny: %s", x, y)
, type = "scatter", mode = "lines", line = list(shape = "spline"), name = .x
)
})
p <- plotly::plot_ly()
purrr::map(
c("guder", "logis", "atan", "tanh", "gen"), ~{
y = do.call(sigmoid
, args = list(input = seq_along(x), family = .x, k = 0.2, center = median))
p <<- plotly::add_lines(
p = p, x = x, y = y
, hovertext = sprintf("x: %s\ny: %s", x, y)
, type = "scatter", line = list(shape = "spline"), name = .x
)
})
sigmoid <- function(input, family = "logistic", center = mean, debug = FALSE, ...){
#' {0,N} Sigmoid Scaler
#'
#' \code{sigmoid} Scales the input to a range of {0,N} using the sigmoid function
#'
#' The input must contain positive and negative values when \code{centered == FALSE}
#'
#' Function arguments for each sigmoid family are as follows:
#' \enumerate{
#'   \item \code{"generalized"}: \code{list(A, K, C, Q, B, v)}
#'   \item \code{"logistic"}: \code{list(L, K)}
#'   \item \code{"gompertz"}: \code{list(N_0, C, A)}
#' }
#' Families \code{tanh}, \code{atan}, and \code{guder}(mannian) only take the input as its argument
#'
#' @section References:
#' \enumerate{
#' \item{\href{https://en.m.wikipedia.org/wiki/Generalised_logistic_function}{Generalized Logistic Function}}
#' \item{\href{https://en.m.wikipedia.org/wiki/Sigmoid_function}{Sigmoid Function}}
#' \item{\href{https://en.m.wikipedia.org/wiki/Gompertz_function}{Gompertz Function}}
#' \item{\href{https://en.m.wikipedia.org/wiki/Gudermannian_function}{Gudermannian Function}}
#' }
#'
#' @param input (numeric vector or coercible vector)
#' @param family (string | "logistic") The family of sigmoid equation to use: Currently, only "logistic", "generalized", and "gompertz" are supported
#' @center A function that returns the 'center' of \code{input}
#' @param ... Valid elements that populate the arguments of \code{type} based on the selected \code{family} (see `Details`)
#'
#' @return A numeric vector of domain {0, N}
#'
#' @export
input = as.complex(as.numeric(unlist(input)));
if (debug) (print(list(...)));
# Initialize the internal environment with defaults
L <- K <- A <- C <- Q <- B <- N_0 <- v <- 1;
family <- (substitute(c(family)))[-1]
# Capture the internal environment
env <- environment((function(){}));
# Overwrite existing variables with supplied values
list2env(rlang::list2(...), envir = env);
# Set the expression list for sigmoid families
sig.family <- { rlang::exprs(
generalized = A + (K - A)/(C + (Q * exp(-1 * B * input)))^(1/v)
, gompertz  = A * exp(-B * exp(-C * input))
, logistic	= L/(1 + exp(-K * (input - center(input))))
, tanh			= { exp(input) - exp(-input) } / { exp(input) + exp(-input) }
, atan			= atan(input)
, guder			= 2 * atan(tanh(input/2))
)}
# Evaluate the family with the supplied arguments
output <- eval(sig.family[[which(grepl(paste0("^", family), x = names(sig.family)))]]);
if (all(Im(output) == 0)){ Re(output) } else { output }
}
x <- sort(x)
p <- plotly::plot_ly()
purrr::map(
c("guder", "logis", "atan", "tanh", "gen", "gom"), ~{
y = do.call(sigmoid
, args = list(input = seq_along(x), family = .x, k = 0.2, center = median))
p <<- plotly::add_lines(
p = p, x = x, y = y
, hovertext = sprintf("x: %s\ny: %s", x, y)
, type = "scatter", line = list(shape = "spline"), name = .x
)
})
sigmoid <- function(input, family = "logistic", center = mean, debug = FALSE, ...){
#' {0,N} Sigmoid Scaler
#'
#' \code{sigmoid} Scales the input to a range of {0,N} using the sigmoid function
#'
#' The input must contain positive and negative values when \code{centered == FALSE}
#'
#' Function arguments for each sigmoid family are as follows:
#' \enumerate{
#'   \item \code{"generalized"}: \code{list(A, K, C, Q, B, v)}
#'   \item \code{"logistic"}: \code{list(L, K)}
#'   \item \code{"gompertz"}: \code{list(A, B, C)}
#' }
#' Families \code{tanh}, \code{atan}, and \code{guder}(mannian) only take the input as its argument
#'
#' @section References:
#' \enumerate{
#' \item{\href{https://en.m.wikipedia.org/wiki/Generalised_logistic_function}{Generalized Logistic Function}}
#' \item{\href{https://en.m.wikipedia.org/wiki/Sigmoid_function}{Sigmoid Function}}
#' \item{\href{https://en.m.wikipedia.org/wiki/Gompertz_function}{Gompertz Function}}
#' \item{\href{https://en.m.wikipedia.org/wiki/Gudermannian_function}{Gudermannian Function}}
#' }
#'
#' @param input (numeric vector or coercible vector)
#' @param family (string | "logistic") The family of sigmoid equation to use: Currently, only "logistic", "generalized", and "gompertz" are supported
#' @center A function that returns the 'center' of \code{input}
#' @param ... Valid elements that populate the arguments of \code{type} based on the selected \code{family} (see `Details`)
#'
#' @return A numeric vector of domain {0, N}
#'
#' @export
input = as.complex(as.numeric(unlist(input)));
if (debug) (print(list(...)));
# Initialize the internal environment with defaults
L <- K <- A <- C <- Q <- B <- v <- 1;
family <- (substitute(c(family)))[-1];
# Capture the internal environment
env <- environment((function(){}));
# Overwrite existing variables with supplied values
list2env(rlang::list2(...), envir = env);
# Set the expression list for sigmoid families
sig.family <- { rlang::exprs(
generalized = A + (K - A)/(C + (Q * exp(-1 * B * input)))^(1/v)
, gompertz  = A * exp(-B * exp(-C * input))
, logistic	= L/(1 + exp(-K * (input - center(input))))
, tanh			= { exp(input) - exp(-input) } / { exp(input) + exp(-input) }
, atan			= atan(input)
, guder			= 2 * atan(tanh(input/2))
)}
# Evaluate the family with the supplied arguments
output <- eval(sig.family[[which(grepl(paste0("^", family), x = names(sig.family)))]]);
if (all(Im(output) == 0)){ Re(output) } else { output }
}
library(book.of.features)
library(book.of.features)
# ::::: VALIDATION :::::
# bin.windows() ====
library(book.of.utilities)
bin.windows(10)
bin.windows(c(5, 50), use.bin = 3)
bin.windows(array(1:10, dim = 10), use.bin = 3)
bin.windows(i = 10, use.bin = 5)
library(book.of.features)
bin.windows(i = 10, use.bin = 5)
debug(bin.windows)
bin.windows(i = 10, use.bin = 5)
bin.windows(i = 10, use.bin = 5)
c(-Inf, min(this.bin) - 1, this.bin, suppressWarnings(keep(diff(this.bin) +
this.bin + 1, ~.x <= max(this.bin))), max(this.bin) +
1, Inf) %>% sort(decreasing = .dir) %>% make.windows(2,
2)
c(-Inf, min(this.bin) - 1, this.bin, suppressWarnings(keep(diff(this.bin) +
this.bin + 1, ~.x <= max(this.bin))), max(this.bin) +
1, Inf) %>% sort(decreasing = .dir)
c(-Inf, min(this.bin) - 1, this.bin, suppressWarnings(keep(diff(this.bin) +
this.bin + 1, ~.x <= max(this.bin))), max(this.bin) +
1, Inf) %>% sort(decreasing = .dir) %>% make.windows(2,
2)
make.windows(c(1:60), 2, 2)
debug(make.windows)
make.windows(c(1:100), 2, 2)
# make.windows() ----
x <- sample(10, 20, TRUE)
seq_along(x) %% 3
seq_along(x) == 3
cumsum(seq_along(x) == 3)
seq_along(x) == 3
which(seq_along(x) == 3)
which(seq_along(x) %% 3 == 0)
which(seq_along(x) %% 1 == 0)
which(seq_along(x) %% 2 == 0)
which(seq_along(x) %% 4 == 0)
# make.windows() ----
x <- sample(10, 23, TRUE)
which(seq_along(x) %% 4 == 0)
cummax(seq_along(x) %% 4 == 0)
cummax(which(seq_along(x) %% 4 == 0))
which(seq_along(x) %% 4 == 0)
which(seq_along(x) %% 4 != 0)
which(seq_along(x) %% 4 == 0)
?cut
cut(x, which(seq_along(x) %% 4 == 0))
cut(x, breaks = which(seq_along(x) %% 4 == 0))
which(seq_along(x) %% 4 == 0)
c(1, which(seq_along(x) %% 4 == 0) - 1)
which(seq_along(x) %% 4 == 0) + 1
which(seq_along(x) %% 4 == 0) + 1 - 4
which(seq_along(x) %% 4 == 0) + 1 - 4
which(seq_along(x) %% 4 == 0) + 1
, which(seq_along(x) %% 4 == 0) + 1) %>% transpose()
list(
which(seq_along(x) %% 4 == 0) + 1 - 4
, which(seq_along(x) %% 4 == 0) + 1
) %>% transpose()
`:`
map2(
which(seq_along(x) %% 4 == 0) + 1 - 4
, which(seq_along(x) %% 4 == 0) + 1
, `:`
)
which(seq_along(x) %% 4 1 != 0)
which(seq_along(x) %% 4 != 0)
, which(seq_along(x) %% 4 == 0)
which(seq_along(x) %% 4 == 0)
y <- list()
while(length(x) > 0){
y <- c(y, list(x[1:4]))
x <- x[-c(1:4)]
}
# make.windows() ----
x <- sample(10, 97, TRUE)
y <- list()
while(length(x) > 0){
y <- c(y, list(na.omit(x[1:4])))
x <- x[-c(1:4)]
}
# make.windows() ----
x <- sample(10, 97, TRUE)
y <- list()
while(length(x) > 0){
y <- c(y, list(x[1:4] %>% .[!is.na(.)]))
x <- x[-c(1:4)]
}
# make.windows() ----
x <- sample(10, 97, TRUE)
y <- list()
a = 5
b = 1
while(length(x) > 0){
y <- c(y, list(x[1:a] %>% .[!is.na(.)]))
x <- x[-c(1:b)]
}
rm(a, b)
post <- function(i){ lapply(i, `*`, 3)}
post <- function(i){ lapply(i, `*`, 3)}
while(length(x) > 0){
y <- c(y, list(x[1:window.size] %>% .[!is.na(.)]))
x <- x[-c(1:increment)]
} %>% post()
post(y)
y
rm(x, y)
# make.windows() ----
series <- sample(10, 97, TRUE)
output <- list()
window.size <- 10
increment <- 3
post <- function(i){ lapply(i, `*`, 3)}
while(length(series) > 0){
output <- c(y, list(x[1:window.size] %>% .[!is.na(.)]))
series <- series[-c(1:increment)]
}
# make.windows() ----
series <- sample(10, 97, TRUE)
output <- list()
window.size <- 10
increment <- 3
post <- function(i){ lapply(i, `*`, 3)}
while(length(series) > 0){
output <- c(output, list(series[1:window.size] %>% .[!is.na(.)]))
series <- series[-c(1:increment)]
}
post(output)
library(book.of.features)
make.windows(c(1:100), 2, 2)
make.windows(c(1:100), 7, 5)
bin.windows(i = 10, use.bin = 5)
bin.windows(i = 10)
bin.windows(c(5, 50), use.bin = 3)
bin.windows(array(1:10, dim = 10), use.bin = 3)
array(1:10, dim = 10)
X <- cbind(
a = sample(70, 30)
, b = sample(100, 30)
, c = sample(10, 30, TRUE)
) %>% as.arr %>% bin.windows(use.bin = 7)
dim(X)
X <- cbind(
a = sample(70, 30)
, b = sample(100, 30)
, c = sample(10, 30, TRUE)
) %>% as.arr %>% bin.windows(use.bin = 7)
X <- cbind(
a = sample(70, 30)
, b = sample(100, 30)
, c = sample(10, 30, TRUE)
) %>% as.array() %>% bin.windows(use.bin = 7)
dim(X)
X
X <- bin.windows(
i = array(data = sample(100:200, 60)
, dim = c(10, 2, 3)
, dimnames = map2(c(10, 2, 3), LETTERS[1:3], ~rep.int(.y, .x))
)
, use.bin = 7
)
dim(X)
X[1,1,]
X[1,2,]
X[,,2]
X[1,2,3]
define(x = mtcars, map(.SD, as.list) ~ 1)
?y
?by
# continuity ----
x <- for(i %in% 1:100){ sample(10, 5) }
# continuity ----
x <- map(1:100, ~sample(10, 5)) %>% unlist()
x
# continuity ----
x <- map(1:100, ~sample(100, 20)) %>% unlist() %>% sort()
x
# continuity ----
x <- map(1:100, ~sample(100, 20) %>% sort()) %>% unlist()
x
c(0, diff(x))
# continuity ----
x <- data.table(
v = map(1:100, ~sample(100, 20) %>% sort()) %>% unlist()
, g = sample(LETTERS[1:4], 2000, TRUE)
)
X
x
by(data = x, INDICES = unique(x$g))
split(x, by = g)
split(x, by = "g")
# continuity ----
x <- data.table(
v = map(1:100, ~sample(100, 20) %>% sort()) %>% unlist()
, g = sample(LETTERS[1:4], 2000, TRUE)
, i = sample(100, 2000, TRUE)
)[, j = i + sample(100, 2000, TRUE)]
rm(X)
# continuity ----
x <- data.table(
v = map(1:100, ~sample(100, 20) %>% sort()) %>% unlist()
, g = sample(LETTERS[1:4], 2000, TRUE)
, i = sample(100, 2000, TRUE)
)[, j = i + sample(100, 2000, TRUE)]
# continuity ----
x <- data.table(
v = map(1:100, ~sample(100, 20) %>% sort()) %>% unlist()
, g = sample(LETTERS[1:4], 2000, TRUE)
, i = sample(100, 2000, TRUE)
)[, j := i + sample(100, 2000, TRUE)]
setkey(x, g, i, j)
View(x)
# continuity ----
x <- data.table(
g = sample(LETTERS[1:4], 2000, TRUE)
, i = sample(100, 2000, TRUE)
)[, j := i + sample(100, 2000, TRUE)]
View(x)
# continuity ----
x <- data.table(
g = sample(LETTERS[1:4], 2000, TRUE)
, i = sample(100, 2000, TRUE)
)[, j := i + sample(100, 2000, TRUE)]
setkey(x, g, i, j)
setorder(x, g, i, j)
setorder(x, c("g", "i", "j"))
setorder(x, g, i, j)
View(x)
# continuity ----
x <- data.table(
g = sample(LETTERS[1:4], 2000, TRUE)
, i = sample(100, 2000, TRUE)
)[, j := i + sample(100, 2000, TRUE)]
setorder(x, g, i, j)
View(x)
library(book.of.features)
make.windows(c(1:100), 2, 2)
make.windows(c(1:100), 7, 5)
bin.windows(i = 10)
bin.windows(c(5, 50), use.bin = 3)
bin.windows(array(1:10, dim = 10), use.bin = 3)
X <- cbind(
a = sample(70, 30)
, b = sample(100, 30)
, c = sample(10, 30, TRUE)
) %>% as.array() %>% bin.windows(use.bin = 7)
dim(X)
X
X <- bin.windows(
i = array(data = sample(100:200, 60)
, dim = c(10, 2, 3)
, dimnames = map2(c(10, 2, 3), LETTERS[1:3], ~rep.int(.y, .x))
)
, use.bin = 7
)
dim(X)
X[1,1,]
X[1,2,]
X[,,2]
X[1,2,3]
X <- bin.windows(array(sample(50:500, 120), dim = c(5, 4, 3, 2), dimnames = map2(c(5, 4, 3, 2), LETTERS[1:4], ~rep.int(.y, .x))), use.bin = 20)
dim(X)
X[1,1,,]
X[3,2,3, ]
X[,,3,1]
X[5,2,3, 1]
library(book.of.features)
# debug(make.windows)
make.windows(c(1:100), 2, 2)
make.windows(c(1:100), 7, 5)
bin.windows(i = 10)
library(book.of.features)
# debug(make.windows)
make.windows(c(1:100), 2, 2)
make.windows(c(1:100), 7, 5)
bin.windows(i = 10)
library(book.of.features)
library(book.of.features)
bin.windows(i = 10)
library(book.of.features)
bin.windows(i = 10)
library(book.of.features)
bin.windows(i = 10)
library(book.of.features)
bin.windows(i = 10)
bin.windows(c(5, 50), use.bin = 3)
bin.windows(array(1:10, dim = 10), use.bin = 3)
X <- cbind(
a = sample(70, 30)
, b = sample(100, 30)
, c = sample(10, 30, TRUE)
) %>% as.array() %>% bin.windows(use.bin = 7)
X <- cbind(
a = sample(70, 30)
, b = sample(100, 30)
, c = sample(10, 30, TRUE)
) |> as.array() |> bin.windows(use.bin = 7)
dim(X)
X
X <- bin.windows(
i = array(data = sample(100:200, 60)
, dim = c(10, 2, 3)
, dimnames = map2(c(10, 2, 3), LETTERS[1:3], ~rep.int(.y, .x))
)
, use.bin = 7
)
X <- bin.windows(
i = array(data = sample(100:200, 60)
, dim = c(10, 2, 3)
, dimnames = purrr::map2(c(10, 2, 3), LETTERS[1:3], ~rep.int(.y, .x))
)
, use.bin = 7
)
dim(X)
X[1,1,]
X[1,2,]
X[,,2]
X[1,2,3]
X <- bin.windows(array(sample(50:500, 120), dim = c(5, 4, 3, 2), dimnames = map2(c(5, 4, 3, 2), LETTERS[1:4], ~rep.int(.y, .x))), use.bin = 20)
X <- bin.windows(array(sample(50:500, 120), dim = c(5, 4, 3, 2), dimnames = purrr::map2(c(5, 4, 3, 2), LETTERS[1:4], ~rep.int(.y, .x))), use.bin = 20)
dim(X)
X[1,1,,]
X[3,2,3, ]
X[,,3,1]
X[5,2,3, 1]
library(book.of.features)
library(book.of.features)
library(book.of.features)
