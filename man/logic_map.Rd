% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/book.of.features.R
\name{logic_map}
\alias{logic_map}
\title{Logical Test Occurrence Map}
\usage{
logic_map(
  fvec,
  avec = rep(1, length(fvec)),
  bvec = sort(unique(fvec)),
  cmp_test = `==`,
  logical.out = FALSE,
  regex = FALSE,
  chatty = FALSE
)
}
\arguments{
\item{fvec}{(vector) Values to be tested: may be a simple vector or a list of tuples}

\item{avec}{(vector) Optional vector of numeric values to project \emph{a}cross the basis vector}

\item{bvec}{(vector) A vector of unique values forming the basis of comparison  If given as a named list, the output will preserve the names when creating columns; otherwise, the values of \code{bvec} are used as the names.}

\item{cmp_test}{(function|\code{`==`}) A two-valued function resulting in a logical vector.  The first argument \strong{must} be vectorized over \code{bvec} and able to compare each element in \code{fvec} to \code{bvec}. If \code{'test'} is provided as the argument, the same functionality as setting argument \code{regex} to \code{TRUE} is invoked.}

\item{logical.out}{(logical, vector) When \code{TRUE}, the output consists of logical values; when a vector of length two (2) is supplied, the first value returns on \code{FALSE}, the second on \code{TRUE}; otherwise, the values of \code{avec} are used.  If the vector form is used, only the first value at each position is used to supply the choices.}

\item{regex}{(logical | \code{FALSE}) When \code{TRUE}, argument \code{bvec} is interpreted as patterns against which case-sensitive matches are sought are attempted.  This forces the value of \code{test} to invoke \code{\link[data.table]{like}}.}

\item{chatty}{(logical | \code{FALSE}) When \code{TRUE}, additional information is printed to console}
}
\value{
Invisibly, a data.table object, the column names being the values of \code{bvec} or names of \code{bvec} if they exist
}
\description{
\code{logic_map} conducts a test of a vector or list of tuples against a vector of unique values. The test can be one of \code{identity}, pattern-matching, or some custom function with Boolean output. Parallelism is supported with a registered \code{\link[foreach]{foreach}} backend.  If no backend is registered, \code{\link[foreach]{registerDoSEQ}} is used as a default.
}
\section{\strong{Restriction}}{

\code{length(fvec) == length(avec)}
}

\section{\strong{Warning}}{

When combining with the source object, \code{fvec} must \strong{NOT} be sorted during the function call or the values will not map correctly in the output.
}

\examples{
n <- 20

fvec <- list(
	ex_1 = sample(LETTERS[1:10], n, TRUE)
	, ex_2 = sample(LETTERS[seq(2,20,2)], n, TRUE)
	, ex_3 = data.table::transpose(list(sample(LETTERS[seq(2,20,2)], n, TRUE), sample(LETTERS[seq(2,20,2)], n, TRUE)))
	, ex_4 = colors() \%>\% sample(4) \%>\% sample(n, TRUE)
	, ex_5 = list(
		colors() \%>\% sample(4) \%>\% sample(n, TRUE)
		, sample(letters[seq(2,20,2)], n, TRUE)
	) \%>\% data.table::transpose() \%>\% purrr::map(unlist, recursive = FALSE)
);

avec <- sample(seq(1, 30, 0.75), n, TRUE);
bvec <- list(
	set_1 = fvec$ex_2 \%>\% unique() \%>\% sample(5)
	, set_2 = sprintf("[\%s\%s]{1,3}", sample(letters, 10), sample(letters, 10))
);

purrr::map(fvec[1:3], book.of.features::xform.basis_vector, avec = avec, bvec = bvec$set_1);
purrr::map(fvec[1:3], book.of.features::xform.basis_vector, avec = avec, bvec = bvec$set_1, logical.out = TRUE);

data.table::data.table(fvec$ex_4, book.of.features::xform.basis_vector(fvec$ex_4, avec = avec))
data.table::data.table(fvec$ex_4, book.of.features::xform.basis_vector(fvec$ex_4, avec = avec, bvec = bvec$set_2, regex = TRUE))
data.table::data.table(fvec$ex_5, book.of.features::xform.basis_vector(fvec$ex_5, avec = avec, bvec = bvec$set_2, regex = TRUE))
data.table::data.table(fvec$ex_5, book.of.features::xform.basis_vector(fvec$ex_5, avec = avec, bvec = bvec$set_2, regex = TRUE, logical.out = TRUE))

}
